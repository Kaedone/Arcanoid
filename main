# Подключаем графическую библиотеку
from tkinter import *
# Подключаем модули, которые отвечают за время и случайные числа
import time
import random

# Создаём новый объект — окно с игровым полем.
# В нашем случае переменная окна называется tk, и мы его сделали из класса Tk() — он есть в графической библиотеке
tk = Tk()
# Делаем заголовок окна — Games с помощью свойства объекта title
tk.title('Arcanoid')
# Запрещаем менять размеры окна
tk.resizable(0, 0)
# Помещаем наше игровое окно выше остальных окон на компьютере, чтобы другие окна не могли его заслонить
tk.wm_attributes('-topmost', 1)
# Создаём новый холст, где и будем рисовать игру
canvas = Canvas(tk, width=500, height=400, highlightthickness=0)
# Говорим холсту, что у каждого видимого элемента будут свои отдельные координаты
canvas.pack()
# Обновляем окно с холстом
tk.update()


# Описываем класс Ball
class Ball:
    """Отвечает за шарик: задание начального положения и направления движения, касания платформы, само-отрисовка"""
    # Конструктор
    def __init__(self, canvas, paddle, score, color):
        # Задаём параметры объекта
        self.canvas = canvas
        self.paddle = paddle
        self.score = score

        self.id = canvas.create_oval(10, 10, 25, 25, fill=color)
        # Помещаем шарик в "стартовое" положение (245,100)
        self.canvas.move(self.id, 245, 100)
        # Выбираем ветор движения
        self.x = random.randint(-2, 2)
        # Вначале он всегда падает
        self.y = -2
        # Определяем высоту и ширину
        self.canvas_height = self.canvas.winfo_height()
        self.canvas_width = self.canvas.winfo_width()
        # Определяем выпал ли он за границы мира
        self.hit_bottom = False

    # Обработка касания платформы (4 координаты в переменной pos)
    # (левая верхняя и правая нижняя точки)
    def hit_paddle(self, pos):
        # Получение координат платформы через объект paddle
        paddle_pos = self.canvas.coords(self.paddle.id)
        # Когда координаты касания совпадают с координатами платформы (шарик упал на неё)
        if pos[2] >= paddle_pos[0] and pos[0] <= paddle_pos[2]:
            if paddle_pos[1] <= pos[3] <= paddle_pos[3]:
                # Счётчик + 1 (обработчик этого события будет описан ниже)
                self.score.hit()
                # Возвращаем метку касания
                return True
        # Иначе говорим что касания небыло (шарик недолетел либо выпал)
        return False

    # Отрисовка шарика
    def draw(self):
        # Перемещение шарика на данные координаты заданные координаты x и y
        self.canvas.move(self.id, self.x, self.y)
        # Сохраняем новые координаты шарика
        pos = self.canvas.coords(self.id)
        # Если шарик падает сверху
        if pos[1] <= 0:
            # Задаём падение на следующем шаге = 2 (ускоряем)
            self.y = 2
        # Если шарик правым нижним углом коснулся дна (выпал)
        if pos[3] >= self.canvas_height:
            # Помечаем это в отдельной переменной
            self.hit_bottom = True
            # Выводим сообщение и количество очков
            canvas.create_text(250, 120, text='Вы проиграли', font=('Courier', 30), fill='red')
        # Если шарик коснулся платформы (отскочил)
        if self.hit_paddle(pos):
            # Отправляем шарик наверх
            self.y = -2
        # Если коснулся левой стенки
        if pos[0] <= 0:
            # Движем его вправо
            self.x = 2
        # Если коснулся правой стенки
        if pos[2] >= self.canvas_width:
            # Движем его влево
            self.x = -2
