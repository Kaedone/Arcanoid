# Подключаем графическую библиотеку
from tkinter import *
# Подключаем модули, которые отвечают за время и случайные числа
import time
import random

# Создаём новый объект — окно с игровым полем.
# В нашем случае переменная окна называется tk, и мы его сделали из класса Tk() — он есть в графической библиотеке
tk = Tk()
# Делаем заголовок окна — Games с помощью свойства объекта title
tk.title('Arcanoid')
# Запрещаем менять размеры окна
tk.resizable(0, 0)
# Помещаем наше игровое окно выше остальных окон на компьютере, чтобы другие окна не могли его заслонить
tk.wm_attributes('-topmost', 1)
# Создаём новый холст, где и будем рисовать игру
canvas = Canvas(tk, width=500, height=400, highlightthickness=0)
# Говорим холсту, что у каждого видимого элемента будут свои отдельные координаты
canvas.pack()
# Обновляем окно с холстом
tk.update()


# Описываем класс Ball
class Ball:
    """Отвечает за шарик: задание начального положения и направления движения, касания платформы, само-отрисовка"""

    # Конструктор
    def __init__(self, canvas, paddle, score, color):
        # Задаём параметры объекта
        self.canvas = canvas
        self.paddle = paddle
        self.score = score

        self.id = canvas.create_oval(10, 10, 25, 25, fill=color)
        # Помещаем шарик в "стартовое" положение (245,100)
        self.canvas.move(self.id, 245, 100)
        # Выбираем ветор движения
        self.x = random.randint(-2, 2)
        # Вначале он всегда падает
        self.y = -2
        # Определяем высоту и ширину
        self.canvas_height = self.canvas.winfo_height()
        self.canvas_width = self.canvas.winfo_width()
        # Определяем выпал ли он за границы мира
        self.hit_bottom = False

    # Обработка касания платформы (4 координаты в переменной pos)
    # (левая верхняя и правая нижняя точки)
    def hit_paddle(self, pos):
        # Получение координат платформы через объект paddle
        paddle_pos = self.canvas.coords(self.paddle.id)
        # Когда координаты касания совпадают с координатами платформы (шарик упал на неё)
        if pos[2] >= paddle_pos[0] and pos[0] <= paddle_pos[2]:
            if paddle_pos[1] <= pos[3] <= paddle_pos[3]:
                # Счётчик + 1 (обработчик этого события будет описан ниже)
                self.score.hit()
                # Возвращаем метку касания
                return True
        # Иначе говорим что касания небыло (шарик недолетел либо выпал)
        return False

    # Отрисовка шарика
    def draw(self):
        # Перемещение шарика на данные координаты заданные координаты x и y
        self.canvas.move(self.id, self.x, self.y)
        # Сохраняем новые координаты шарика
        pos = self.canvas.coords(self.id)
        # Если шарик падает сверху
        if pos[1] <= 0:
            # Задаём падение на следующем шаге = 2 (ускоряем)
            self.y = 2
        # Если шарик правым нижним углом коснулся дна (выпал)
        if pos[3] >= self.canvas_height:
            # Помечаем это в отдельной переменной
            self.hit_bottom = True
            # Выводим сообщение и количество очков
            canvas.create_text(250, 120, text='Вы проиграли', font=('Courier', 30), fill='red')
        # Если шарик коснулся платформы (отскочил)
        if self.hit_paddle(pos):
            # Отправляем шарик наверх
            self.y = -2
        # Если коснулся левой стенки
        if pos[0] <= 0:
            # Движем его вправо
            self.x = 2
        # Если коснулся правой стенки
        if pos[2] >= self.canvas_width:
            # Движем его влево
            self.x = -2


#  Описываем класс Paddle (отрисовка платформы)
class Paddle:
    # конструктор
    def __init__(self, canvas, color):
        # Платформа рисуется на том же самом холсте
        self.canvas = canvas
        # Создаем платформу и получаем её внутреннее имя
        self.id = canvas.create_rectangle(0, 0, 100, 10, fill=color)
        # Все возможные стартовые положения платформы
        start_1 = [40, 60, 90, 120, 150, 180, 200]
        # Случайная стартовая точка для платформы
        self.starting_point_x = random.choice(start_1)
        # Ставим платформу на старт
        self.canvas.move(self.id, self.starting_point_x, 300)
        # Платформа стоит
        self.x = 0
        # Узнаём ширину
        self.canvas_width = self.canvas.winfo_width()
        # Обработчик нажатий:
        # Метод turn_right() если нажата стрелка вправо
        self.canvas.bind_all('<KeyPress-Right>', self.turn_right)
        # Метод turn_left() если стрелка влево
        self.canvas.bind_all('<KeyPress-Left>', self.turn_left)
        # Ожидание начала игры
        self.started = False
        # Запускаем игру, как только нажат энтер
        self.canvas.bind_all('<KeyPress-Return>', self.start_game)

    # Движение вправо
    def turn_right(self, event):
        # Минимальное смещение, на 1 пиксель по оси x
        self.x = 1

    # Движение влево
    def turn_left(self, event):
        # Минимальное смещение, на 1 пиксель по оси x
        self.x = -1

    # Начало игры
    def start_game(self, event):
        # Запуск
        self.started = True

    # Движение платформы
    def draw(self):
        # Сдвигаем платформу на заданное количество пикселей (1 пиксель)
        self.canvas.move(self.id, self.x, 0)
        # Координаты холста
        pos = self.canvas.coords(self.id)
        # Что-бы не врезаться в границу (в левую)
        if pos[0] <= 0:
            # Остановка (не выезжаем за край)
            self.x = 0
        # Что-бы не врезаться в границы (в правую)
        elif pos[2] >= self.canvas_width:
            # Остановка (не выезжаем за край)
            self.x = 0
